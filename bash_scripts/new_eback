#!/bin/bash

if [[ "$(whoami)" != "root" ]]; then
	echo "Must be run as root. Try 'sudo !!'"
	exit 0
fi


main() {
    trap sig_close SIGINT
	trap sig_close SIGTERM
	trap sig_close SIGHUP

	clear

	FORCE_SCAN=false
	SKIP_SCAN=false
	UNSAFE_MOUNT=false
	DEVICE_SCAN_GRACE_PERIOD=1200
	MOUNTED_DEV=""
	REM_MIN=1024

	while getopts "fsu :" OPTION; do
		case $OPTION in
		f)
			FORCE_SCAN=true
			;;
		s)
			SKIP_SCAN=true
			;;
		u)
			UNSAFE_MOUNT=true
			;;
		*)
			echo "Incorrect options provided."
			exit 1
			;;
		esac
	done

	housing_dir="/opt/server-setup-scripts/external-backups" # to be changed to /etc/.../ when upon finalizing
	timestamp_loc="$housing_dir/lastdate"
	devdata_loc="$housing_dir/devices"
	reservedata_loc="$housing_dir/reserved"
	lastback_stamp_loc="$housing_dir/.lastback"
	dirlist_loc="$housing_dir/dirs"

	if [[ ! -f "${timestamp_loc}" ]]; then
		touch ${timestamp_loc}
	fi
	if [[ ! -f "${devdata_loc}" ]]; then
		touch ${devdata_loc}
	fi
	if [[ ! -f "${reservedata_loc}" ]]; then
		touch ${reservedata_loc}
	fi
	if [[ ! -f "${dirlist_loc}" ]]; then
		touch ${dirlist_loc}
	fi

    if [[ "$SKIP_SCAN" == "true" ]]; then
		echo -e "\e[33mDevice scan manually overridden.\e[0m"
	elif [[ "$FORCE_SCAN" == "false" && -f "$timestamp_loc" ]]; then
		last_date=`cat $timestamp_loc`

		if [[ "${last_date}" == "" ]]; then last_date=0; fi
		sec_since=$((`date +%s` - $last_date))

		if [[ $sec_since -lt $DEVICE_SCAN_GRACE_PERIOD ]]; then
			echo -e "\e[33mScanned devices ${sec_since}s ago, skipping.\e[0m"

			SKIP_SCAN=true
		fi
	fi

    if [[ "$SKIP_SCAN" == "false" ]]; then
		scan_devices

		echo -e "\e[33mDevices discovered:\e[0m"
		print_device_info
	else
		load_data
	fi


    run_loop
}

run_loop() {
	while [ 1 -eq 1 ]; do
		read -p "Command (h for help): " input

		case ${input:0:1} in
		a)
			add_directory ${input:2:${#input}}
			;;
		d)
			dir_list
			;;
		r)
			remove_directory ${input:2:${#input}}
			;;
		i)
			print_device_info
			;;
		s)
			scan_devices
			print_device_info
			;;
		l)
			if [[ -f "$lastback_stamp_loc" ]]; then 
				echo -n "The last system backup occurred on: "
				cat $lastback_stamp_loc 
			else
				echo "The system has not been backed up yet."
			fi
			;;
		h)
			help_message
			;;
		q)
			echo "Goodbye."
			exit_fxn
			exit 0
			;;
		*)
			echo "$input: Unknown command."
			;;
		esac
	done
}

dir_list() {
	list=(`cat ${dirlist_loc}`)
	for item in ${list[@]}; do
		echo -e "  -->\t\e[32m${item}\e[39m"
	done
}

# $1 should be the directory to be added
add_directory() {
	if [[ "$1" == "" ]]; then
		echo "Usage: a <directory>"
		return
	fi

	abs_path=`realpath $1`
	if [[ ! -d "$abs_path" ]]; then
		echo "The directory $abs_path/ does not exist."
		return
	fi

	matches=(`grep "$abs_path/" ${dirlist_loc}`)
	for item in ${matches[@]}; do
		if [[ "$item" == "$abs_path/" ]]; then
			echo "$abs_path/ is already in the backup list."
			return
		fi
	done

	echo "Adding $abs_path/ to the directory list."
	echo "$abs_path/" >> ${dirlist_loc}
}

# $1 should be the directory to be removed
remove_directory() {
	if [[ "$1" == "" ]]; then
		echo "Usage: r <directory>"
		return
	fi

	abs_path=`realpath $1`
	list=(`cat ${dirlist_loc}`)

	exact=0
	for item in ${list[@]}; do
		if [[ "$item" == "$abs_path/" ]]; then
			exact=1
		else
			echo "$item" >> ${dirlist_loc}.tmp
		fi
	done

	if [[ $exact -eq 0 ]]; then
		rm ${dirlist_loc}.tmp
		echo "$abs_path/ is not in the directory list."
		return
	else
		mv ${dirlist_loc}.tmp ${dirlist_loc}
		echo "Removed $abs_path/ from the directory list."
	fi


}

save_data() {
	# Order: devs(), dev_IDs(), dev_labels(), dev_sizes(), dev_reserved(), dev_remaining()
	touch ${devdata_loc}.tmp
	for i in $(seq 0 $((${#devs[@]}-1))); do
		printf "${devs[$i]}\$${dev_IDs[$i]}\$${dev_labels[$i]}\$${dev_sizes[$i]}\n" >> ${devdata_loc}.tmp
	done

	mv ${devdata_loc}.tmp ${devdata_loc}
}

load_data() {
	# Order: devs(), dev_IDs(), dev_labels(), dev_sizes()
	devs=()
	dev_IDs=()
	dev_labels=()
	dev_sizes=()

	if [[ ! -f "$devdata_loc" ]]; then
		echo "An unknown error occurred, please try again."
		rm $timestamp_loc
		exit 1
	else
		i=0
		while IFS= read -r line; do
			devs=(${devs[@]} `echo "$line" | cut -d'$' -f1`)
			dev_IDs=(${dev_IDs[@]} `echo "$line" | cut -d'$' -f2`)

			inval=`echo "$line" | cut -d'$' -f3`
			fix_space # returns to $retval
			dev_labels[$i]="$retval"

			dev_sizes=(${dev_sizes[@]} `echo "$line" | cut -d'$' -f4`)
			i=$((i+1))
		done < "$devdata_loc"
	fi
}

print_device_info() {
	if [[ ${#devs[@]} -eq 0 ]]; then
		echo "No external devices were found, try attaching some and try again."
	else
		for i in $(seq 0 $((${#devs[@]}-1))); do

			make_readable ${dev_sizes[$i]}
			total_size="$retval"
			remaining_size="$retval"

			printf "\t╔ ${dev_labels[$i]} [\e[33m${dev_IDs[$i]}\e[0m]\n\t╚ \e[33m/dev/${devs[$i]}\e[0m, \e[32m${total_size}\e[0m\n"
			[[ $i -ne $((${#devs[@]}-1)) ]] && printf "\n" || :
		done
	fi
}

make_readable() {
	# Usage: $0 <bytes>[K]
	# Legible value returned via $retval

	if [[ "$1" == *"K" ]]; then
		retval=`echo $1 | numfmt --from=iec --to=iec`
	else
		retval=`echo $1 | numfmt --from=none --to=iec`
	fi

	return 0
}

scan_devices() {
	potential_devs=()
	devs=()
	dev_IDs=()
	dev_labels=()
	dev_sizes=()
	set_potential_devs
	tmpdir=`mktemp -d`

	for device in ${potential_devs[@]}; do
		status=`mount | grep $device`

		printf "Scanning /dev/$device...\t"
		if [[ "$status" == "" ]]; then
			MOUNTED_DEV="/dev/$device"

			if [[ !$UNSAFE_SCAN ]]; then
				count=`ps aux | grep "mount ${MOUNTED_DEV}" | wc -l`
				if [[ $count -ge 2 ]]; then
					printf "Failed; it looks like ${MOUNTED_DEV} is being mounted elsewhere.\n\t\t\tTo attempt to mount ${MOUNTED_DEV} regardless, use -u\n"
					continue
				fi
			fi

			ret=`mount /dev/$device $tmpdir &> /dev/null`
			if [[ $ret -ne 0 ]]; then
				echo "Failed, $ret"
				umount /dev/$device &> /dev/null
				MOUNTED_DEV=""
			elif [[ ! -f "$tmpdir/check_stamp.nat" ]]; then
				echo "Not properly formatted"
				umount /dev/$device &> /dev/null
				MOUNTED_DEV=""
			else
				size=`df $tmpdir | awk ' { print $2 } ' | cut -d$'\n' -f 2 | cut -d '%' -f 1`
				no_K_size=`echo ${size}K | numfmt --from=iec --to=none` # df displays disk space in 1K blocks, we want it strictly in bytes
#				dev_sizes=(${dev_sizes[@]} $no_K_size)

#				devs=(${devs[@]} $device)
				dev_ID=`ls -l /dev/disk/by-uuid | grep $device | awk '{print $9}'`
#				dev_IDs=(${dev_IDs[@]} $dev_ID)

				label=`ls -l /dev/disk/by-label | grep $device | awk '{print $9}'`
				if [[ "$label" == "" ]]; then label="No\x20label\x20found"; fi
#				dev_labels=(${dev_labels[@]} $label)

				grep_res=(`cat $reservedata_loc | grep -n $dev_ID | cut -d':' -f1`)
				if [[ "$grep_res" != "" ]]; then
					reserved_size=0
					for k in $(seq 0 $((${#grep_res[@]} - 1))); do
						reserved_size=$((reserved_size + `cat $reservedata_loc | sed -n "$((${grep_res[$k]} - 1))p" | cut -d':' -f2 | numfmt --from=iec --to=none`))
					done

					if [[ $(($no_K_size - $reserved_size)) -lt $REM_MIN ]]; then
						umount $tmpdir
						MOUNTED_DEV=""
						echo -e "\e[33mFull\e[0m"
						continue
					fi
				fi

				devs=(${devs[@]} $device)
				dev_sizes=(${dev_sizes[@]} $no_K_size)
				dev_IDs=(${dev_IDs[@]} $dev_ID)
				dev_labels=(${dev_labels[@]} $label)

				echo "Formatted"

				umount $tmpdir
				MOUNTED_DEV=""
			fi
		else
			echo "Failed because this device is already mounted."
		fi
	done

	date +%s > $timestamp_loc
	save_data

	rmdir $tmpdir
}

sig_close() {
	echo
	printf "SIGINT, SIGTERM or SIGHUP received, exiting..."

	exit_fxn

	printf " goodbye.\n"
	exit 0
}

fix_space() {
	# Usage: $0, with $inval set to the input string
	retval=`echo "$inval" | sed 's/ /\\x20/g'`
	return 0
}

set_potential_devs() {
	potential_devs=(`ls -l /dev/disk/by-uuid | awk '{print $11}' | cut -d'/' -f3 | grep "sd*"`)
	return 0
}

exit_fxn() {
	rm $tmpdir &> /dev/null
	rm $tmpdata &> /dev/null
	[[ "$MOUNTED_DEV" != "" ]] && umount $MOUNTED_DEV &> /dev/null || :
}

help_message() {
		#	    -a) Adding directories to the backups
        #       -r) Removing directories from the backups
        #       -i) Printing out info about all the backups
        #       -l) Print when the last backup occurred
		#       -s) Rescan device data
        #       -h) Help command
        #       -q) Quit
        #       *) Make executable program that gets put in crontab and does the actual backing up (probably same as previous *)

	echo -e "\n\e[33m\e[4mCommands\e[0m"
	echo -e "\ta) Add a directory to the backup system"
	echo -e "\tr) Remove a directory from the backup system"
	echo -e "\ti) Display size information about the available external drives"
	echo -e "\ts) Rescan available external devices"
	echo -e "\th) Display this info message"
	echo -e "\tl) Print when the last backup occurred"
	echo -e "\tq) Quit\n"
}

main "$@"